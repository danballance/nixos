i# Modular NixOS Configuration with Home‑Manager

## Current Setup and Challenges

Your current NixOS flake config is functional but fairly monolithic. It defines a single `nixosConfigurations.nixos` with everything (system settings, desktop environment, and your Home Manager user config) lumped together. For example, **`base.nix`** contains many system settings (locale, X/Wayland, user account, etc.), while **`home.nix`** holds your user’s Hyprland and application configs. This works, but it’s a bit chaotic – toggling between GNOME and Hyprland by commenting modules, and mixing system-level packages with user-level ones. As configurations grow, a single flat file (or a few large files) becomes bloated and hard to maintain. It’s great that you got things working as a NixOS beginner, but now we can refactor to a cleaner, modular layout.

## Goals for a Refactored Layout

Based on your answers and future plans, the new structure should achieve several goals:

- **Clear separation of system vs user (Home Manager) configs:** Decide what belongs in global _NixOS_ modules vs what goes in _Home Manager_ (user-level) modules. This avoids confusion about where to put each setting.
- **Multi-machine support:** Organize configs so adding a new machine (another NixOS system, a Nix-Darwin Mac, or even a NixOS server) is straightforward. The layout should accommodate host-specific settings while sharing common code.
- **Reusable modules:** Encapsulate features or configurations into modules that can be reused across different hosts (e.g. a “desktop GUI” module, an “editor setup” module). This avoids duplicating code and makes enabling/disabling features easier.
- **Fast iteration workflow:** Enable quick testing of changes. Ideally, you want to tweak settings locally and apply them (to just your user config or a test VM) without always doing a full system rebuild or committing to Git first. Keeping Home Manager configs decoupled (so you can `home-manager switch` independently) or using NixOS test builds/VMs can help.
- **Use Nix flakes throughout:** Continue using flakes for pinning Nixpkgs and managing configs consistently across NixOS, Nix-Darwin, and Home Manager.

There isn’t one “official” structure that everyone uses, but there are community best practices and popular templates we can draw from. Below is a recommended modular template that is well-regarded and aligns with your needs.

## Recommended Modular Structure

A common approach is to split your configuration into **separate files and directories** by purpose, and leverage the Nix module system’s `imports` to combine them. For example, one well-known community config is structured with clearly separated folders for hosts and modules. Adapting that idea, you could organize your repo like this:

- **`flake.nix`:** The central flake entry point. It will define inputs (NixOS/Nixpkgs, Home Manager, nix-darwin, etc.) and outputs for each system and user configuration. It essentially ties everything together – listing each machine’s NixOS configuration and each user’s Home Manager config. (We’ll discuss how in a moment.)
- **`hosts/` directory:** Contains **one NixOS config per machine** (and optionally one Nix-Darwin config per Mac). For example, `hosts/my-desktop.nix` for your current NixOS machine (perhaps rename “nixos” to a real hostname), `hosts/my-mac.nix` for your MacBook (using nix-darwin), and maybe `hosts/my-vps.nix` for a future server. Each host file will import the common modules it needs and set any host-specific options (like machine hostname, hardware config, unique packages or services). This makes it easy to add or remove entire machines.
- **`home/` directory:** Contains **Home Manager configs for each user** (possibly qualified by host). Since you likely have one primary user across machines, you might have a file like `home/anoni-desktop.nix` for your user on NixOS and `home/anoni-mac.nix` for the Mac (if you want slight differences on macOS). If you intend to use the _same_ home config on all machines, you could have a single `home/anoni.nix`. But given NixOS vs macOS differences, it’s often easiest to have one per host or to parameterize the home config by OS. In our flake, we will reference these under `homeConfigurations` so that you can build/switch them independently when needed.
- **`modules/` directory:** Contains **reusable modules** that encapsulate portions of your configuration. You can subdivide this further for clarity:
  - `modules/nixos/` – NixOS system modules (global system configuration). For example, you might have `desktop.nix` enabling your GUI, `networking.nix` for network settings, `dev-tools.nix` for development tools, etc. Your existing `base.nix` can be split into a few of these logical pieces or kept as one “base” module that imports others.
  - `modules/home-manager/` – Home Manager modules (user-level config). For instance, a `shell.nix` module setting up Fish/Zsh and shell aliases, a `gui-apps.nix` module with GUI applications and related settings, an `editors.nix` for Neovim/VSCodium config, etc. This lets you group home config by domain. Each Home Manager module is basically an attr set for `home.` options (programs, home.packages, etc.) that will be merged.
  - `modules/darwin/` – (Optional) Mac-specific system modules if using nix-darwin. Nix-Darwin has its own options (similar to NixOS modules but for macOS). If you plan to mirror some configs on Mac, you can have modules here, e.g. `darwin/gui.nix` or `darwin/dev.nix`, or you can just handle Mac specifics inside the `hosts/my-mac.nix`. This folder just keeps Darwin stuff separate from Linux stuff.
  - You can create other subfolders or categories as needed (some people also use `modules/common/` vs `modules/host-specific/`, etc., but the above split is a good starting point).
- **`overlays/` directory (optional):** If you maintain custom overlays or packages, keep them here. You might already use an overlay for VSCode extensions; moving it to `overlays/vscode.nix` (for example) and pointing your flake to import it is cleaner. The flake can merge all files in `overlays/` as overlays for nixpkgs.
- **`hardware/` (or just include in hosts):** It’s common to keep each machine’s `hardware-configuration.nix` (generated by the NixOS installer) either embedded in that host’s config or saved as a separate file. You could make a `hosts/my-desktop-hardware.nix` and have `hosts/my-desktop.nix` import it. This way, hardware specifics (disk partitions, device drivers) stay isolated.

This structure gives you a clear hierarchy: **each host has a top-level config that pulls in the relevant modules**. Those modules implement features and are reusable across hosts. For example, you might have a `modules/nixos/wayland.nix` that enables `programs.hyprland` and other Wayland-wide settings, and a corresponding `modules/home-manager/hyprland.nix` that sets up Hyprland keybindings (the content you currently have in your `home.nix`). Your desktop host config would import both to get the full Hyprland setup, whereas another host (say a GNOME laptop) would not import those. This “mix and match” approach is exactly what Nix’s module system is good at – it will merge all imported modules, and you avoid duplicating code across machines.

## System (Global) vs Home Manager Config

A key design decision is what goes into NixOS modules vs Home Manager. In general:

- **NixOS modules (system-wide):** Use these for anything that requires root or affects the whole system. This includes hardware config, system services/daemons, networking, firewall, display server (X11/Wayland) and login managers, system-wide package installations, user creation, and any **global defaults**. For example, enabling Hyprland or Gnome as a system service (so that it’s available as a session) belongs in NixOS config. Your `users.users.anoni` account and groups, `services.xserver` settings, and things like `services.printing` or `security.sudo` rules are all system-level – these stay in NixOS modules. Also, low-level OS settings (bootloader, kernel modules, etc.) remain in NixOS configuration.
- **Home Manager modules (user-specific):** Use these for user applications, dotfiles, and GUI configurations that live in your home directory. HM is perfect for managing your window manager settings (like Hyprland config in `~/.config/hyprland/...`), application themes, editor/IDE settings, shell environment (aliases, shell prompts, etc.), and user-space daemons or services (like a user systemd service). Essentially, if it’s something _only affecting your user_ and can run without root, Home Manager is the right place. In your case, things like Waybar configuration, fish shell setup, git and editor preferences, fonts (if just for your user), and applications like rofi, zellij, etc., should be in the HM config. Many of those are already in your `home.nix` – we’ll just distribute them into logical modules.

There will be some overlap areas, but a rule of thumb is: **if an application can be installed and configured as a normal user, put it in Home Manager; if it needs system integration or should be available to all users, put it in NixOS**. For example, a web browser or editor can be a home package, but something like NetworkManager or Docker must be a system service. In your current config, you did a decent job splitting (e.g. Hyprland’s _enable_ is in NixOS, and its settings in HM). We’ll continue that pattern, just in a cleaner way. Don’t worry if some things could go either place – you can adjust as you refine your preferences.

One practical tweak for convenience: when using flakes, you can actually have Home Manager configurations as separate flake outputs (not only via NixOS modules). For instance, you can define `homeConfigurations.<user>@<host>` in `flake.nix` using `home-manager.lib.homeManagerConfiguration`. Many multi-machine flakes do this so that they can deploy user configs independently of full system rebuilds. In your case, since you like one-step deployment, you might keep using Home Manager as a NixOS module (so `nixos-rebuild` applies everything). But **for fast iteration**, having a `homeConfigurations` output means you could run `home-manager switch --flake path#user@host` to quickly test changes to your home config without rebuilding the whole OS. This is optional, but worth considering as your setup grows. It gives “the best of both worlds” – you can rebuild all at once via `nixosConfigurations`, or just the home part when you’re tweaking dotfiles.

## Multi-Host Setup (Adding Nix-Darwin and More)

The above structure naturally supports multiple hosts. You’ll expand your flake’s outputs like so:

- **Multiple nixosConfigurations:** e.g. `nixosConfigurations.my-desktop` and `nixosConfigurations.my-server`. Each is built by calling `nixpkgs.lib.nixosSystem { ... modules = [ ... ] ... }` with the appropriate list of imports for that machine. For the Mac, you’ll similarly have `darwinConfigurations.my-mac` using the Nix-Darwin lib (from the `darwin` flake input). The Mac’s config will share some Home Manager modules (for user apps) but also include Mac-specific modules or options (like enabling Spotlight, setting defaults, etc., via nix-darwin options).
- **Shared vs host-specific modules:** You can create common module files and use them on any host that needs them. For example, if both your desktop and Mac should have the same dev tools and editor settings, put those in a `modules/home-manager/dev.nix` and import it in both their HM configs. Host-specific quirks (like maybe the desktop needs NVIDIA settings, or the Mac needs specific trackpad settings) can go in that host’s file or a module only imported by that host. Each machine’s top-level config will include the **common base modules** (things like `modules/nixos/common.nix` for settings you want on all systems) plus any **role-specific modules** (e.g. a “desktop GUI” module, a “server headless” module) and **hardware-specific** config. This strategy (common + per-host imports) is a standard way to avoid repetition while still allowing customization.
- **Nix-Darwin integration:** In your flake inputs, add `nix-darwin` (usually `github:LnL7/nix-darwin` or via `nixpkgs` if using the Darwin system flake). Also include `home-manager` as you do now (Home Manager works on macOS too). Your `flake.nix` outputs would get a `darwinConfigurations.my-mac = darwinSystem {...}` similar to nixosSystem. Inside `hosts/my-mac.nix`, you can import many of the same modules (since NixOS and Nix-Darwin both use Nix modules). Of course, skip or condition-out any Linux-specific settings. You might separate `modules/darwin/` for things unique to macOS (like setting up Homebrew compatibility or mac-specific apps). The goal is a **unified repo** controlling all machines. Community flakes often do this to have one dotfiles repo for NixOS and macOS together. For example, AlexNabokikh’s config repository manages NixOS and macOS in one structure, demonstrating that this approach is well-tested and popular.

## Putting It Together (Refactoring Plan)

1. **Restructure the repository:** Create the directories (`hosts/`, `modules/nixos/`, `modules/home-manager/`, etc.) and move your existing configuration into this structure. For instance, take the content of your current `flake.nix` outputs and split it: create `hosts/my-desktop.nix` with what is now in your modules list (importing `../modules/nixos/base.nix`, Hyprland, etc., and your desktop’s `hardware-configuration.nix`). Move user-specific parts out of `base.nix` into Home Manager modules. For now, you can keep `home.nix` as `home/anoni-desktop.nix` (and later split into smaller HM modules). Update `flake.nix` so that:

   - It defines `nixosConfigurations.my-desktop = nixpkgs.lib.nixosSystem { ... modules = [ ./hosts/my-desktop.nix ]; }`.
   - It defines `darwinConfigurations.my-mac = darwinConfigurations { ... modules = [ ./hosts/my-mac.nix ]; }` (when you’re ready for the Mac).
   - Optionally, define `homeConfigurations` for each user. For example: `homeConfigurations."anoni@my-desktop" = home-manager.lib.homeManagerConfiguration { pkgs, ..., modules = [ ./home/anoni-desktop.nix ]; };`. And similarly for the Mac user. This uses Home Manager’s flake support to allow independent HM use. (Remember to include `home-manager` in flake inputs and perhaps `home-manager.url = "github:nix-community/home-manager"; home-manager.inputs.nixpkgs.follows = "nixpkgs";` as you have, or use the new HM flake if stable.)
   - Keep your inputs (nixpkgs, home-manager, niv, hyprland, etc.) as needed. You might also add `nix-darwin` input for the Mac.

2. **Create common modules:** Identify settings and packages that are shared by all (or most) of your machines/users and put them in reusable modules. For example, you might make `modules/nixos/common.nix` that sets things like `nix.settings.experimental-features`, `nixpkgs.config.allowUnfree`, maybe your timezone and locale if all hosts share them. Another might be `modules/nixos/desktop-common.nix` for things common to any desktop (enable PipeWire, printing, GPU drivers, etc.). In Home Manager, maybe a `modules/home-manager/common-programs.nix` that enables `git`, `direnv`, sets up `starship` prompt, etc., that you want for any user. These common modules get imported by relevant host or home configs. This way, to add a new machine, you mostly reuse what’s already defined – you just write a small host file that imports the appropriate pieces and adds whatever new things are needed for that machine.
3. **Split per-feature modules:** To improve maintainability, consider breaking out configurations by feature or domain. For instance, you could have a `modules/nixos/hyprland.nix` (for system parts of Hyprland) and a `modules/home-manager/hyprland.nix` (for user config of Hyprland). Then, rather than toggling commented lines in flake, you simply include or omit those modules for a given host. Your desktop’s config would import both to get Hyprland; if you later set up a GNOME workstation, its host config would import `modules/nixos/gnome.nix` instead. Similarly, you could isolate “development tools” configs, or “media server” configs, etc., and mix them as needed. This approach – using _Nix modules as building blocks_ – is encouraged to keep things organized. It lets you **encapsulate a feature** (even if that feature touches system and home) into a couple of files.
4. **Global vs Home – adjust as needed:** As you refactor, decide for each setting if it belongs in a system module or a home module. For example, you currently install `nerd-fonts.jetbrains-mono` in both system packages and home packages. In a cleanup, you might choose to install fonts system-wide (so all users have them) and remove it from the home packages list. Or vice-versa, if only your user needs it, keep it in HM and remove from system. Another example: `wl-clipboard`, `waybar`, `swaybg` are in your home packages – these could be user-scoped (that’s fine), but something like the polkit agent `polkit-kde-agent-1` might be better as a system service (to ensure it runs on login for any GUI). It’s not wrong to have it in HM, but think about whether it should start even if you don’t launch it manually – if yes, system might be preferable. Use this refactoring as an opportunity to make such choices. In general, aim to minimize duplication and keep each concern in the appropriate layer.
5. **Testing and iteration:** With flakes, you can easily test your new layout. For example, after restructuring, run `nixos-rebuild switch --flake path/to/your/repo#my-desktop` to build your desktop config from the flake. If you set up `homeConfigurations` outputs, you can try `home-manager switch --flake path/to/repo#anoni@my-desktop` to apply just the home config and see if it works independently. During development, you might use `nixos-rebuild test` (which applies changes without making them permanent, so you can roll back on next boot if something breaks). Another tip: define a **VM test config** for quick iteration – e.g. `nixosConfigurations.testVM = nixpkgs.lib.nixosSystem { modules = [ ./hosts/my-desktop.nix <some overrides> ] ... specialArgs = { testVM = true; }; }` and then run `nix run .#nixosConfigurations.testVM.config.system.build.vm` to boot a QEMU VM of your system. This is advanced, but can be useful for trying risky changes. For daily tweaks, though, the combination of separate home-manager switching and the usual NixOS rebuild should suffice for a fast edit-run cycle.

## Conclusion and Resources

By implementing a modular configuration, you’ll make your NixOS setup much more manageable and future-proof. You’ll be able to share the bulk of your config across multiple machines (including your future Mac and servers) while keeping machine-specific details isolated. The structure outlined above is inspired by well-respected community configurations, and it aligns with recommendations from NixOS experts to split configs into “bite-size” modules. In fact, a popular starter template (Misterio77’s _nix-starter-configs_) demonstrates this approach and is highly recommended as a learning resource. Additionally, you might find it helpful to browse others’ dotfiles for ideas – for example, the repository by Alex Nabokikh shows a flake with NixOS + Darwin + Home Manager all in one repo with a similar layout.

Remember, there is no one-size-fits-all solution, so feel free to adjust the module breakdown to what makes sense for you. The key is to keep related settings together, avoid duplication, and make it easy to extend to new systems. With flakes and this modular design, your configuration will be organized, easier to navigate, and much more fun to tinker with. Good luck with the refactoring! 🚀

**Sources:**

- NixOS & Flakes Book – _Modularize Your NixOS Configuration_ (recommendation to split configs)
- NixOS & Flakes Book – Reference to Misterio77’s starter templates (community-endorsed structure)
- AlexNabokikh’s Nix Config – Example of multi-machine NixOS + macOS flake structure
- NixOS Discourse – Advice on multi-host config and no “standard” layout
- Excerpt from AlexNabokikh’s config – showing home-manager flake output per user@host
